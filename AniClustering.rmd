---
title: "Recommending Television Shows from User Ratings"
author: "Matthew Wolff"
output:
  pdf_document: default
  html_document: default
header-includes: 
- \usepackage{longtable}
---
\pagenumbering{gobble}
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE)
```
```{r packages_and_constants}
library(tidyverse)
library(cluster) #clustering
library(mclust) # gaussian mixture modeling
library(FactoMineR) # PCA
library(circlize) # sicc plots
library(kableExtra)
library(viridis)
library(gtools)
library(randomForest)
library(GGally)

blank <- theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"))  # removes most formatting 
blank_w_border <- theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) 
centered <- element_text(hjust = 0.5)
no_legend <- theme(legend.position="none")
```

```{r loading}
raw_shows <- read_csv("~/github/aniclust/data/anime.csv", progress=FALSE)
raw_ratings <- read_csv("~/github/aniclust/data/rating.csv", progress=FALSE)
```

```{r cleaning}
ratings <- raw_ratings %>% mutate(
  user_id = as.integer(user_id),
  anime_id = as.integer(anime_id)
) %>% 
  filter(rating != -1) # eliminate ratings that don't exist

shows <- raw_shows %>% mutate(
  anime_id = as.integer(anime_id),
  episodes = parse_integer(episodes), # not all episode durations are known
  type = factor(type),
  genre = strsplit(genre, ", ")
) %>% 
  filter(!is.na(rating)) %>%
  rename(meanRating = rating)


# manually fill in the total episode number for 5 most popular shows w/missing episode num
unknown_ep_num <- problems(shows$episodes)$row
most_pop_ongoing <- shows[unknown_ep_num,] %>% add_column(row=unknown_ep_num) %>% top_n(5, members)
shows[most_pop_ongoing$row,]$episodes <- c(869, 930, 500, 131, 6)

# remove all the missing episode numbers
shows <- shows %>% filter(!is.na(shows$episodes))
```
```{r missing_values}
raw_shows %>% mutate(episodes = parse_integer(episodes)) %>%
  select(-c(anime_id, genre, name, type)) %>% summary() %>% 
  as.data.frame %>% as_tibble %>% select(-Var1) %>% group_by(Var2) %>%
  mutate(Stat = seq_along(Var2)) %>% spread(key = Stat, value = Freq) %>% t %>% as_tibble %>%
  `colnames<-`(.[1,]) %>% .[-1,] %>% mutate_all(function(x) gsub("^.*?:", "", x, perl = T)) %>%
  `rownames<-`(c("Minimum", "1st Quartile", "Median", "Mean", "3rd Quartile", "Max", "Missing Vals")) %>%
  t %>%
  kable(format = "latex", escape = F, booktabs = T, align='c', linesep = "",
        caption = "Missing Values Within Show Data", longtable=T) %>% gsub("NA", "0", .)
```
```{r visual_exploration, fig.height=3}
### exploratory
# genre distribution (pi/bar chart)
shows$genre %>% unlist %>% plyr::count() %>% 
  .[-c(8,12),] %>% # remove unsavory stuff - we're keeping this appropriate
  top_n(20, freq) %>% 
  rename(Genre = x, Count = freq) %>%
  ggplot() + geom_histogram(mapping = aes(Genre, Count, fill=Genre), stat="identity") +
  blank +
  guides(fill=FALSE) + # remove legend for fill
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = centered) + 
  scale_fill_viridis_d() +
  ggtitle(paste0("Top 20 Most Popular Genres (from ",dim(shows)[1]," shows)"))
```
\begin{minipage}[t]{0.5\textwidth}
\vspace*{-4.5cm}
```{r circle_plot, fig.width=5, fig.align="center"}
# genre association via circlize -- canonical-correlation analysis?
combo <- function(v) { v <- unique(v); if(length(v) > 1) combinations(length(v), 2, v) else NA }
links <- shows$genre %>% sapply(combo) %>%  # generate all pairs per genre list
  do.call(rbind, .) %>% as_tibble() %>%
  transmute(
    from = V1 %>% unlist,
    to   = V2 %>% unlist
  ) %>% 
  filter(!is.na(to) & !is.na(from)) %>% # remove NAs
  plyr::count() %>% 
  top_n(16, freq) # --select top 10 most common pairings-- 16 looks nice tbh

# coloring
set.seed(1966) # for both colors and shuffling the linkages (when they're ordered)
grid.names <- unique(c(links$from, links$to))
grid.colors <- length(grid.names) %>% viridis %>% `names<-`(grid.names)
colors <- dim(links)[1] %>% viridis()
links[sample(nrow(links)),] %>% 
  chordDiagram(scale=T, 
               transparency=0.1, 
               grid.col=grid.colors, col=colors,
               annotationTrack = c("name","grid")) 
title(main="Most Frequent Genre Pairings")
```
\end{minipage}
\begin{minipage}[b]{0.1\textwidth}
\quad
\end{minipage}
\begin{minipage}[b]{0.4\textwidth}
\begin{center}
\textbf{Frequent Pairing Counts}
```{r circle_table}
links %>% rename(Genre1 = from, Genre2 = to, Count = freq) %>% arrange(desc(Count)) %>%
  kable(format = "latex", escape = F, booktabs = T, align='c', linesep = "")
```
\end{center}
\end{minipage}
```{r genre_complexity, fig.height=3}
shows %>% 
  mutate(genre_count = factor(sapply(genre, length))) %>% 
  filter(type %in% c("OVA", "Special", "TV", "Movie")) %>%
  ggplot() + 
  geom_histogram(aes(genre_count, fill=genre_count), stat="count") + 
  scale_fill_viridis(discrete=T) +
  labs(x = "Number of Genres per Show", y = "Count") + 
  ggtitle("Distribution of Genre Complexity") + 
  facet_wrap(~type) +
  blank_w_border +
  theme(plot.title=centered) + 
  no_legend
```
\quad\hfill\break
```{r numerical_correlations}
paired <- shows %>% 
  mutate(`log10(# of Ratings)` = log10(members), `Average Rating` = meanRating) %>% 
  filter(type %in% c("OVA", "Special", "TV", "Movie")) %>%
  select(`Average Rating`, `log10(# of Ratings)`, type) %>%
  ggpairs(aes(fill = type), title="Relationship and Distributions between Show Variables") + 
  blank_w_border +
  theme(plot.title = centered) 
# adjust colors
for(i in 1:paired$nrow){ for(j in 1:paired$ncol){paired[i,j] <- paired[i,j] + scale_fill_viridis_d() }}
paired
```

```{r transform_show_data}
genre_list <- list(c("Drama", "Romance", "School", "Supernatural"))
genres <- unlist(shows$genre) %>% unique %>% sort
encode_genre <- function(genre_list) { 
  genre_list <- genre_list[[1]] %>% .[!is.na(.)]
  uniq <- genre_list %>% .[!is.na(.)] %>% unique # sanitize
  genre_array <- rep(-1, length(genres)) %>% `names<-`(genres) # NA is last
  genre_array[genre_list] <- 1
  genre_array
}
# this might be a bad idea...
encode_popularity <- function(member_num) {
  if(member_num >= 600000) return("Popular") # top 15
  if(member_num >= 50000) return("Common") # top 500
  else return("Niche") # the other 11,500
}
genre_columns <- shows$genre %>% lapply(encode_genre) %>% do.call(rbind, .) %>% as_tibble
df <- bind_cols(shows, genre_columns) %>% select(-c(genre, anime_id, name))

```
```{r random_forest}
# spread
# 
# training_proportion <- 0.85
# train <- sample(1:nrow(df), nrow(df)*training_proportion)
# randomForest(meanRating ~ . , data = df, subset = train)

# cluster principal components -- evaluate
```

